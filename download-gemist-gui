#!/usr/bin/env python
# encoding:utf-8
#
# Download videos from the Dutch `Uitzending gemist' site.
#
# http://code.arp242.net/download-gemist
#
# Copyright © 2012-2013 Martin Tournoij <martin@arp242.net>
# See below for full copyright
#

from __future__ import print_function

import sys
import time

try:
	import threading
except ImportError:
	import dummy_threading as threading

try:
	import Queue as queue
except ImportError:
	import queue

try:
	if sys.version_info[0] == 2:
		import Tkinter as tk
		import ttk
	else:
		import tkinter as tk
		import tkinter.ttk as ttk
except ImportError:
	print('Unable to import Tkinter')
	sys.exit(1)

import dgemist

_queue = queue.Queue()


class GUI:
	def __init__(self, root):
		root.columnconfigure(0, weight=1)

		rootframe = ttk.Frame(root, padding=5)
		rootframe.grid(row=0, column=0, sticky=tk.E + tk.W)
		rootframe.columnconfigure(0, weight=1)

		# Top frame
		topframe = ttk.LabelFrame(rootframe, text='Programma', padding=3)
		topframe.columnconfigure(0, weight=1)

		lbl = ttk.Label(topframe,
			text='URL naar programmapagina (bv. http://www.uitzendinggemist.nl/programmas/215-andere-tijden)')

		self.programinput = ttk.Entry(topframe)
		self.programinput.bind('<Return>', lambda ev: self.programinputbtn.invoke())
		self.programinputbtn = ttk.Button(topframe, text='Ok',
			command=self.populate_eps)

		topframe.grid(column=0, row=0, sticky=tk.W + tk.E)
		lbl.grid(row=0, column=0, sticky=tk.W, columnspan=2)
		self.programinput.grid(row=1, column=0, sticky=tk.W + tk.E)
		self.programinputbtn.grid(row=1, column=1)

		topframe.columnconfigure(0, weight=1)
		topframe.columnconfigure(1, weight=0)

		# Episode list
		self.epframe = ttk.LabelFrame(rootframe, text='Afleveringen', height=400)
		self.epframe.columnconfigure(0, weight=1)
		self.epframe.grid(column=0, row=1, sticky=tk.E + tk.W, pady=10)

		# Bottom
		self.btmframe = ttk.Frame(rootframe)
		self.btmframe.columnconfigure(0, weight=1)
		self.btmframe.columnconfigure(1, weight=1)

		qbtn = ttk.Button(self.btmframe, command=lambda: root.quit(),
			text='Sluiten')
		self.dlbtn = ttk.Button(self.btmframe, command=self.download,
			text='Download geselecteerd afleveringen')
		self.dlbtn.config(state=tk.DISABLED)

		self.btmframe.grid(row=2, column=0, sticky=tk.W + tk.E)
		qbtn.grid(row=0, column=0, sticky=tk.W)
		self.dlbtn.grid(row=0, column=1, sticky=tk.E)

		# XXX
		if 'debug' in sys.argv:
			self.programinput.insert(0, 'http://www.uitzendinggemist.nl/programmas/215-andere-tijden')
			self.populate_eps()

	def populate_eps(self):
		self.programurl = self.programinput.get()

		# TODO: blocks UI
		self.eps = {}
		i = 0
		for epid, title, url, desc in dgemist.GetListing(self.programurl):
			self.eps[epid] = {
				'title': title,
				'url': url,
				'val': tk.BooleanVar(),
			}

			frame = ttk.Frame(self.epframe, padding=3)
			frame.columnconfigure(0, weight=0)
			frame.columnconfigure(1, weight=1)

			cbox = ttk.Checkbutton(frame, text='Download',
				variable=self.eps[epid]['val'])
			lbltitle = ttk.Label(frame, text=title)
			lbldesc = ttk.Label(frame, text=desc, wraplength=600, justify=tk.LEFT)
			sep = ttk.Separator(frame)

			frame.grid(row=i, column=0, sticky=tk.W + tk.E)
			cbox.grid(row=0, column=0, sticky=tk.W)
			lbltitle.grid(row=0, column=1, sticky=tk.W)
			lbldesc.grid(row=1, column=1, sticky=tk.E + tk.W)
			sep.grid(row=2, column=0, columnspan=2, sticky=tk.E + tk.W)

			i += 1

		self.dlbtn.config(state=tk.NORMAL)

	def download(self):
		for epid, data in self.eps.iteritems():
			if data['val'].get() is not True:
				continue

			_queue.put({
				'cmd': 'video',
				'url': data['url'],
			})


def download():
	while True:
		if not _queue.empty():
			cmd = _queue.get()

			if cmd['cmd'] == 'quit':
				return
			elif cmd['cmd'] == 'video':
				# TODO: progress bar, prevent downloading same ep twice
				import subprocess
				proc = subprocess.Popen(['./download-gemist', cmd['url']])
				proc.communicate()
				proc.wait()
			elif cmd['cmd'] == 'list':
				pass

		time.sleep(1)


if __name__ == '__main__':
	root = tk.Tk()
	root.minsize(width=705, height=520)
	root.title('Download-gemist')
	root.bind('<Escape>', lambda ev: root.quit())

	GUI(root)

	thr = threading.Thread(target=download)
	thr.start()

	try:
		root.mainloop()
	finally:
		_queue.put({
			'cmd': 'quit'
		})


# The MIT License (MIT)
#
# Copyright © 2012-2013 Martin Tournoij
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
