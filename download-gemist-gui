#!/usr/bin/env python
# encoding:utf-8
#
# Download videos from the Dutch `Uitzending gemist' site.
#
# http://code.arp242.net/download-gemist
#
# Copyright © 2012-2013 Martin Tournoij <martin@arp242.net>
# See below for full copyright
#
# Een todo-lijstje:
# - Programma's als favorieten opslaan
# - Resize van window werkt niet altijd even goed
# - Knop voor volgende pagina
# - Betere error-feedback
#

from __future__ import print_function
import os, sys, time

try:
	if sys.version_info.major > 2:
		import tkinter as tk
		import tkinter.ttk as ttk
		import tkinter.filedialog as filedialog
		import queue

		try:
			import _thread as thread
		except ImportError:
			import _dummy_thread as thread
	else:
		import Tkinter as tk
		import ttk
		import tkFileDialog as filedialog
		import Queue as queue

		try:
			import thread
		except ImportError:
			import dummy_thread as thread
except ImportError:
	print('Unable to import Tkinter')
	sys.exit(1)

import dgemist


class GUI:
	def __init__(self, root):
		self.queue = queue.Queue()
		self.root = root
		self.root.columnconfigure(0, weight=1)

		self.rootframe = ttk.Frame(self.root, padding=5)
		self.rootframe.grid(row=0, column=0, sticky=tk.E + tk.W)
		self.rootframe.columnconfigure(0, weight=1)

		# Top frame
		topframe = ttk.LabelFrame(self.rootframe, text='Programma', padding=3)
		topframe.columnconfigure(0, weight=1)

		lbl = ttk.Label(topframe, text=('URL naar aflevering- of programma-pagina'))

		self.programinput = ttk.Entry(topframe)
		self.programinput.bind('<Return>', lambda ev: self.programinputbtn.invoke())
		self.programinputbtn = ttk.Button(topframe, text='Okay',
			command=self.click_download)

		topframe.grid(column=0, row=0, sticky=tk.W + tk.E)
		lbl.grid(row=0, column=0, sticky=tk.W, columnspan=2)
		self.programinput.grid(row=1, column=0, sticky=tk.W + tk.E)
		self.programinputbtn.grid(row=1, column=1)

		topframe.columnconfigure(0, weight=1)
		topframe.columnconfigure(1, weight=0)

		# Bottom
		self.btmframe = ttk.Frame(self.rootframe, padding=5)
		self.btmframe.columnconfigure(0, weight=1)
		self.btmframe.columnconfigure(1, weight=1)

		qbtn = ttk.Button(self.btmframe, command=lambda: self.root.quit(),
			text='Sluiten')

		self.btmframe.grid(row=2, column=0, sticky=tk.W + tk.E)
		qbtn.grid(row=0, column=2, sticky=tk.W)

		if 'debug1' in sys.argv:
			self.programinput.insert(0,
				'http://www.uitzendinggemist.nl/programmas/215-andere-tijden')
			self.click_download()
		if 'debug2' in sys.argv:
			self.programinput.insert(0,
				'http://www.uitzendinggemist.nl/afleveringen/1346967')
			self.click_download()


	def click_download(self):
		self.programurl = self.programinput.get().strip()

		if self.programurl == '': return

		if 'programmas' in self.programurl:
			self.populate_eps()
		else:
			self.download_single(self.programurl)


	def populate_eps(self):
		self.epframe = ttk.LabelFrame(self.rootframe, text='Afleveringen', height=400)
		self.epframe.columnconfigure(0, weight=1)
		self.epframe.grid(column=0, row=1, sticky=tk.E + tk.W, pady=10)

		self.eps = {}
		self.cboxes = []
		i = 0
		for epid, title, url, desc in dgemist.GetListing(self.programurl):
			self.eps[epid] = {
				'title': title,
				'url': url,
				'val': tk.BooleanVar(),
			}

			frame = ttk.Frame(self.epframe, padding=3)
			frame.columnconfigure(0, weight=0)
			frame.columnconfigure(1, weight=1)

			cbox = ttk.Checkbutton(frame, text='Download',
				variable=self.eps[epid]['val'])
			lbltitle = ttk.Label(frame, text=title)
			lbldesc = ttk.Label(frame, text=desc, wraplength=600, justify=tk.LEFT)
			sep = ttk.Separator(frame)

			frame.grid(row=i, column=0, sticky=tk.W + tk.E)
			cbox.grid(row=0, column=0, sticky=tk.W)
			lbltitle.grid(row=0, column=1, sticky=tk.W)
			lbldesc.grid(row=1, column=1, sticky=tk.E + tk.W)
			sep.grid(row=2, column=0, columnspan=2, sticky=tk.E + tk.W)

			self.cboxes.append(cbox)

			i += 1

		self.dlbtn = ttk.Button(self.epframe,
				command=lambda: thread.start_new_thread(self.download_listing, ()),
			text='Download geselecteerd afleveringen')
		self.dlbtn.config(state=tk.DISABLED)
		self.dlbtn.grid(row=i + 1, column=0, sticky=tk.E)
		self.dlbtn.config(state=tk.NORMAL)


	def download_listing(self):
		destdir = filedialog.askdirectory(initialdir=os.path.expanduser('~'),
			parent=self.root, title='Selecteer map om bestanden op te slaan')

		# Cancel button or window closed
		if destdir == '': return

		self.dlbtn.config(state=tk.DISABLED)
		for c in self.cboxes: c.config(state=tk.DISABLED)

		for epid, data in self.eps.iteritems():
			if data['val'].get() is not True: continue

			self.download(destdir, data['url'])

			while self.thr:
				time.sleep(0.5)


	def download_single(self, url):
		destdir = filedialog.askdirectory(initialdir=os.path.expanduser('~'),
			parent=self.root, title='Selecteer map om bestanden op te slaan')

		# Cancel button or window closed
		if destdir == '': return

		self.download(destdir, url)


	def download(self, destdir, url):
		self.progwin = tk.Toplevel(self.root, takefocus=True)
		self.progwin.transient(self.root)
		self.progwin.title('download-gemist voortgang')
		self.progwin.minsize(width=650, height=95)
		self.progwin.columnconfigure(0, weight=1)
		
		self.programinput.configure(state=tk.DISABLED)
		self.programinputbtn.configure(state=tk.DISABLED)

		progframe = ttk.Frame(self.progwin, padding=5)
		progframe.columnconfigure(0, weight=1)

		self.progress = tk.IntVar()
		self.progresslbl = tk.StringVar()

		proglbl = tk.Label(progframe, textvariable=self.progresslbl)
		progbar = ttk.Progressbar(progframe, length=300, variable=self.progress)

		btnframe = ttk.Frame(self.progwin, padding=5)
		btnframe.columnconfigure(0, weight=1)
		cancelbtn = ttk.Button(btnframe, text='Annuleren',
			command=self.progwin.destroy)

		progframe.grid(row=0, column=0, sticky=tk.E + tk.W)
		btnframe.grid(row=1, column=0, sticky=tk.E + tk.W)

		proglbl.grid(row=0, column=0, sticky=tk.W + tk.E)
		progbar.grid(row=1, column=0, sticky=tk.W + tk.E)
		cancelbtn.grid(row=0, column=0, sticky=tk.E)

		self.thr = None
		self.cancel_download = False

		self.progress.set(0)
		self.progresslbl.set('Starten van download...')

		self.thr = thread.start_new_thread(self.BackgroundDownload,
			(url, destdir))

		self.update_prog()


	def update_prog(self):
		try:
			self.progwin.state()
		except tk.TclError:
			self.programinput.configure(state=tk.NORMAL)
			self.programinputbtn.configure(state=tk.NORMAL)
			if self.thr: self.cancel_download = True
			self.thr = None
			return

		try:
			while True:
				self.queue.get_nowait()()
		except queue.Empty:
			pass

		self.root.after(100, self.update_prog)


	def BackgroundDownload(self, url, destdir):
		""" Download videos in thread """
		try:
			videourl, title, epid, cookie = dgemist.FindVideo(url)
			outfile = dgemist.MakeFilename(destdir, title, epid,
				overwrite=True)
		# TODO: popup messagebox, wait for Ok click
		except dgemist.DgemistError as e:
			Error(e.message)
			self.queue.put(lambda: self.progwin.destroy())
			thread.exit()

		if 'debug' in sys.argv:
			self.queue.put(lambda: self.progresslbl.set('Debug %s' % url))
			time.sleep(5)
			self.queue.put(lambda: self.progwin.destroy())
			thread.exit()

		pcomplete = -1
		starttime = time.time()
		ptime = remaining = 0
		for total, completed, speed in dgemist.DownloadVideo(videourl, cookie, outfile):
			if self.cancel_download:
				self.queue.put(lambda: self.progwin.destroy())
				thread.exit()
			completepc = int(completed / (total / 100))
			curtime = time.time()

			if completepc != pcomplete:
				self.queue.put(lambda: self.progress.set(completepc))
				pcomplete = completepc

			if curtime - starttime > 2:
				speed = int(completed / (curtime - starttime))
				if speed == 0:
					remaining = 100
				else:
					remaining = (total - completed) / speed

			if curtime >= ptime + 1:
				if speed == 0:
					remaining = 100
				else:
					remaining = (total - completed) / speed
				line = ('%(complete)3s%% van %(total)s, '
					+ 'nog %(remaining)4s te gaan met %(speed)4s/s') % ({
					'total': dgemist.HumanSize(total),
					'complete': completepc,
					'speed': dgemist.HumanSize(speed),
					'remaining': dgemist.HumanTime(remaining),
				})
				self.queue.put(lambda: self.progresslbl.set('%s%s' % (title, line)))
				ptime = curtime

		self.queue.put(lambda: self.progwin.destroy())
		thread.exit()


def Error(msg):
	""" Print message to stderr, can't use print because of Python 2/3
	incompatibility """
	sys.stderr.write('Error: %s\n' % msg)

if __name__ == '__main__':
	print('Experimenteel...')
	root = tk.Tk()
	root.minsize(width=705, height=120)
	root.title('Download-gemist')
	root.bind('<Escape>', lambda ev: root.quit())

	s = ttk.Style()
	s.theme_use('clam')

	GUI(root)

	try:
		root.mainloop()
	except KeyboardInterrupt:
		pass


# The MIT License (MIT)
#
# Copyright © 2012-2013 Martin Tournoij
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# The software is provided "as is", without warranty of any kind, express or
# implied, including but not limited to the warranties of merchantability,
# fitness for a particular purpose and noninfringement. In no event shall the
# authors or copyright holders be liable for any claim, damages or other
# liability, whether in an action of contract, tort or otherwise, arising
# from, out of or in connection with the software or the use or other dealings
# in the software.
